<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Lua | 左轮]]></title>
  <link href="http://ypengju.github.io/blog/categories/lua/atom.xml" rel="self"/>
  <link href="http://ypengju.github.io/"/>
  <updated>2015-01-10T14:15:00+08:00</updated>
  <id>http://ypengju.github.io/</id>
  <author>
    <name><![CDATA[左轮]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Lua -- Stack]]></title>
    <link href="http://ypengju.github.io/blog/2014/11/11/lua-stack/"/>
    <updated>2014-11-11T21:32:01+08:00</updated>
    <id>http://ypengju.github.io/blog/2014/11/11/lua-stack</id>
    <content type="html"><![CDATA[<p>c++调用lua中一个很重要的概念就是栈，它是c++与lua交互的基础，所有的调用都是在这个栈上来完成的，所以我想在这片文章中记录下我对栈调用的一些理解。之前有读过子龙山人的关于lua文章，这里使用他的配置，具体见这片博文：<a href="http://4gamers.cn/blog/2014/06/28/embeded-lua-tutorial-one/">Lua教程: C++嵌入Lua脚本(1)</a>，我也是按照这篇博文进行配置，使用的lua版本为5.2.3。<!-- more --> <br/>
看lua的api可以知道，lua库提供的方法主要分为三个类：</p>

<ul>
<li>Lua functions     &ndash;lua代码中使用的函数库</li>
<li>C API             &ndash;c中使用的函数库</li>
<li>auxiliary library &ndash;辅助库，是对c函数的包装</li>
</ul>


<p>先来看一个简单的例子，看c++如何调用lua文件</p>

<pre><code class="c++ ">#include &lt;iostream&gt;
#include "lua.hpp"

int main(int argc, const char * argv[]) {

    //1. 初始化Lua虚拟机，初始话新lua栈
    lua_State *lua_state;
    lua_state = luaL_newstate();

    //2. 打开所有的标准库
    luaL_openlibs(lua_state);

    //3、运行hello.lua脚本
    luaL_dofile(lua_state, "hello.lua");

    //4. 关闭Lua虚拟机
    lua_close(lua_state);

}
</code></pre>

<p>首先在使用之前需要导入头文件，这里导入lua.hpp，同时导入如下三个类库：</p>

<pre><code class="c++ lua.hpp">extern "C" {
#include "lua.h"
#include "lualib.h"
#include "lauxlib.h"
}
</code></pre>

<p>lua.h和lualib.h包含以lua<em>为前缀的C API库，lauxlib.h包含以luaL</em>为前缀的辅助类库。</p>

<ol>
<li>首先初始化lua虚拟机，也是就初始化一个新的调用栈</li>
<li>打开所有的标准库，也可以根据需要只导入需要的库</li>
<li>加载和运行lua文件</li>
<li>当调用完成后，需要关掉栈</li>
</ol>


<pre><code class="lua hello.lua">print("hello world")
</code></pre>

<p>此时运行程序便可以看到调用lua文件打印的hello world。 <br/>
像上边程序一样，我们在进行c++调用lua之前都会创建一个新的栈，然后所有的操作都是通过栈来进行的，为什么需要这样做？ <br/>
因为lua是动态语言，c++是静态语言，lua的变量可能是任意一种类型，无法直接与c变量对应起来，而且lua是一种嵌入式语言，它不仅可以嵌套在c++中使用，也可能会嵌套在其他语言中使用，那这种对应关系就更复杂了。所以就采用了这种虚拟栈的交互方式，当c++和lua相互调用的时候，先将变量压入栈中，然后由另一端从栈中取出，然后转换成对应类型进行处理，所以lua提供了如下这些将不同类型压入栈的操作：<br/>
<code>c++
void lua_pushnil(lua_State *L)
void lua_pushboolean (lua_State *L, int bool);
void lua_pushnumber (lua_State *L, lua_Number n);
void lua_pushinteger (lua_State *L, lua_Integer n);
void lua_pushunsigned (lua_State *L, lua_Unsigned n);
const char *lua_pushstring (lua_State *L, const char *s);
const char *lua_pushstring (lua_State *L, const char *s);
</code> <br/>
另一个原因就是内存的管理，c++中是手动进行内存释放的，而在lua中是采用自动垃圾回收处理的，如果你保存一个lua的table在c++变量中，lua无法知道这个table在c++中是否使用，在lua中可能由于不使用而被标记为垃圾而回收。 <br/>
对于不同类型操作，lua不仅定义了上边的<code>lua_pushXXX</code>函数，还定义了<code>void lua_isXXXX(lua_State *L, int index)</code>等c函数库用来辨别栈中具体位置的变量是哪种类型。和<code>lua_toXXXX(lua_State *L, int index)</code>函数，将栈中对应位置的元素转换为具体类型返回。除了上边这些，lua还提供了一些对栈顶操作，替换栈内元素，删除等操作：</p>

<pre><code class="c++">int lua_gettop (lua_State *L);
void lua_settop (lua_State *L, int index);
void lua_pushvalue (lua_State *L, int index);
void lua_remove (lua_State *L, int index);
void lua_insert (lua_State *L, int index);
void lua_replace (lua_State *L, int index);
void lua_copy (lua_State *L, int fromidx, int toidx);
</code></pre>

<p>下边具体看个例子，对栈的操作：</p>

<pre><code>lua_State *lua_state = luaL_newstate();

lua_pushboolean(lua_state, 1);
lua_pushnumber(lua_state, 100);
lua_pushstring(lua_state, "hello world");

int top = lua_gettop(lua_state);

printf("------first------\n");
for (int i = 1; i &lt;= top; i++) {
    int t = lua_type(lua_state, i);
    switch (t) {
        case LUA_TSTRING:
            printf("%s  \n", lua_tostring(lua_state, i));
            break;
        case LUA_TNUMBER:
            printf("%g  \n", lua_tonumber(lua_state, i));
            break;
        case LUA_TBOOLEAN:
            printf(lua_toboolean(lua_state, i) ? "true  \n" : "false  \n");
            break;
        default:
            break;
    }
}

printf("-------second--------\n");
for (int i =-1; i &gt;= -top; i--) {
    int t = lua_type(lua_state, i);
    switch (t) {
        case LUA_TSTRING:
            printf("%s  \n", lua_tostring(lua_state, i));
            break;
        case LUA_TNUMBER:
            printf("%g  \n", lua_tonumber(lua_state, i));
            break;
        case LUA_TBOOLEAN:
            printf(lua_toboolean(lua_state, i) ? "true  \n" : "false  \n");
            break;
        default:
            break;
    }
}
</code></pre>

<p>运行打印结果为：</p>

<pre><code>------first------
true  
100  
hello world  
-------second--------
hello world  
100  
true  
</code></pre>

<p>首先生成新的栈，然后依次向其中压入true，100，&#8221;hello world&#8221;，采用<code>lua_gettop(luaState *L)</code>获取栈中元素个数，第一次遍历从栈底到栈顶，第二次遍历从栈顶到栈底。   <br/>
默认情况下，lua栈的大小为20个存储空间，大多数情况下足够程序使用，但有些情况下我们可能需要更多的栈空间，这时就可以采用<code>lua_checkstack(lua_State *L, int sz)</code>检查栈空间是否够用。由上边打印的结果可以看到，第一个push进去的值的索引为1，接着第二个位2，换句话说，从栈底到栈顶的顺序为1到n。同时栈顶也可以用-1索引访问，所以栈顶到栈底也可以用-1到-n遍历访问。在好多操作中，会经常看到用索引-1，访问栈顶元素。除了用-1索引操作外，我们还可以直接用<code>lua_settop</code>和<code>lua_gettop</code>函数操作栈顶。<br/>
以上就是对栈的一个简单操作，对于更加复杂的如对lua函数，Table操作等，也都是基于栈来操作的。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Lua -- 面向对象编程]]></title>
    <link href="http://ypengju.github.io/blog/2014/10/13/lua-mian-xiang-dui-xiang-bian-cheng/"/>
    <updated>2014-10-13T22:08:10+08:00</updated>
    <id>http://ypengju.github.io/blog/2014/10/13/lua-mian-xiang-dui-xiang-bian-cheng</id>
    <content type="html"><![CDATA[<p>在了解表的使用，以及元表和元方法的使用后，就可以用表来实现面向对象编程了。</p>

<h3>类</h3>

<p>面向对象编程的核心就是类了，先来看看lua怎么实现类，并通过类生成不同实例。   <!-- more --></p>

<pre><code class="lua Class">local Account = {}
function Account:new( o )
    o = o or {}
    setmetatable(o, self)
    self.__index = self
    return o
end
function Account:printBalance(  )
    print("Account balance = " .. self.balance)
end
a = Account:new{ balance = 1 }
b = Account:new{ balance = 2}
a:printBalance() -- Account balance = 1
b:printBalance() -- Account balance = 2
</code></pre>

<p>生成了两个实例a，b，都可以调用printBalance()函数打印内容，那么就来分析一下：</p>

<ul>
<li>首先调用<code>Accout:new{ balance = 1 }</code>将一个表传入new()函数中，如果传入参数为空，赋值一个空的表</li>
<li>设置表o的元表为Account，此时的self代表Account</li>
<li>设置Account表的<code>__index</code>域为自己，然后返回表o，此时得到一个元表为Account的表</li>
<li>当调用printBalance()表的时候，在返回的表中没有定义此方法，所以会去访问返回表的元表    <code>__index</code>域，这个域是Account表,并在表Account定义了printBalance()方法，所以就调用了Account表中定义的printBalance()方法。</li>
<li>a:printBalance()时，此时self就是a表，所以self.balance就是a表中的balance，所以就打印1</li>
</ul>


<p>这样就定义了一个简单的类，使得new出来的实例，可以调用类中定义的方法。</p>

<h3>继承</h3>

<p>有类就要有继承，再看lua怎么实现继承 <br/>
<figure class='code'><figcaption><span>继承</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
</pre></td><td class='code'><pre><code class='lua'><span class='line'><span class="kd">local</span> <span class="n">Account</span> <span class="o">=</span> <span class="p">{</span> <span class="n">balance</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">}</span>
</span><span class='line'><span class="k">function</span> <span class="nf">Account</span><span class="p">:</span><span class="n">new</span><span class="p">(</span> <span class="n">o</span> <span class="p">)</span>
</span><span class='line'>    <span class="n">o</span> <span class="o">=</span> <span class="n">o</span> <span class="ow">or</span> <span class="p">{}</span>
</span><span class='line'>    <span class="nb">setmetatable</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">self</span><span class="p">)</span>
</span><span class='line'>    <span class="n">self</span><span class="p">.</span><span class="n">__index</span> <span class="o">=</span> <span class="n">self</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">o</span>
</span><span class='line'><span class="k">end</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">function</span> <span class="nf">Account</span><span class="p">:</span><span class="n">printBalance</span><span class="p">(</span>  <span class="p">)</span>
</span><span class='line'>    <span class="nb">print</span><span class="p">(</span><span class="err">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="n">Account</span> <span class="n">balance</span> <span class="o">=</span> <span class="err">&amp;</span><span class="n">rdquo</span><span class="p">;</span> <span class="o">..</span> <span class="n">self</span><span class="p">.</span><span class="n">balance</span><span class="p">)</span>
</span><span class='line'><span class="k">end</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">function</span> <span class="nf">Account</span><span class="p">:</span><span class="n">addBalance</span><span class="p">(</span> <span class="n">v</span> <span class="p">)</span>
</span><span class='line'>    <span class="k">if</span> <span class="nb">tonumber</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">then</span>
</span><span class='line'>        <span class="n">self</span><span class="p">.</span><span class="n">balance</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">balance</span> <span class="o">+</span> <span class="n">v</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'><span class="k">end</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="n">SubAccount</span> <span class="o">=</span> <span class="n">Account</span><span class="p">:</span><span class="n">new</span><span class="p">()</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">function</span> <span class="nf">SubAccount</span><span class="p">:</span><span class="n">printSub</span><span class="p">(</span>  <span class="p">)</span>
</span><span class='line'>    <span class="nb">print</span><span class="p">(</span><span class="err">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="n">this</span> <span class="n">is</span> <span class="n">come</span> <span class="n">from</span> <span class="n">subAccount</span><span class="err">&amp;</span><span class="n">rdquo</span><span class="p">;)</span>
</span><span class='line'><span class="k">end</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="n">a</span> <span class="o">=</span> <span class="n">SubAccount</span><span class="p">:</span><span class="n">new</span><span class="p">()</span>
</span><span class='line'><span class="n">a</span><span class="p">:</span><span class="n">printSub</span><span class="p">()</span>        <span class="err">&amp;</span><span class="n">ndash</span><span class="p">;</span> <span class="n">this</span> <span class="n">is</span> <span class="n">come</span> <span class="n">from</span> <span class="n">subAccount</span>
</span><span class='line'><span class="n">a</span><span class="p">:</span><span class="n">printBalance</span><span class="p">()</span>    <span class="err">&amp;</span><span class="n">ndash</span><span class="p">;</span> <span class="n">Account</span> <span class="n">balance</span> <span class="o">=</span> <span class="mi">0</span>
</span><span class='line'><span class="n">a</span><span class="p">:</span><span class="n">addBalance</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
</span><span class='line'><span class="n">a</span><span class="p">:</span><span class="n">printBalance</span><span class="p">()</span>    <span class="err">&amp;</span><span class="n">ndash</span><span class="p">;</span> <span class="n">Account</span> <span class="n">balance</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">&lt;</span><span class="n">br</span><span class="o">/&gt;</span>
</span></code></pre></td></tr></table></div></figure></p>

<ul>
<li>首先定义Account表，相当于父类，其中定义了一个成员变量及两个方法</li>
<li>通过<code>Account:new()</code>定义SubAccount，相当于子类，在子类中定义了printSub()方法。</li>
<li><code>a = SubAccount:new()</code>，用来生成子类的实例，可是SubAccount中并没有定义new()方法，但可以看到SubAccount就是<code>Account:new()</code>返回的一个表，因为传入参数为零，所以此时其实返回的是一个空表，空表中当然没有new()方法，但是这个空表的元表为Account表，并且<code>__index</code>域设置为Account表，所以追中<code>SubAccount:new()</code>调用的就是<code>Account:new()</code>，所以a就是一个表，表的元表就是Account表</li>
<li>当调用printSub()，因为SubAccount定义了printSub，直接调用，相当于子类有这个方法，直接调用子类的方法</li>
<li>调用printBalance()，SubAccount并未定义次方法，所以就会去访问<code>__index</code>域，就会调到<code>Account:printBalance()</code>方法，而在此方法中，调用了self.balance成员，此时的self是a，a中也没有balance定义，所以就会方位<code>__index</code>域，调用<code>Account.balance</code>,最后打印出0</li>
<li>调用addBalance(10)，相当于给Account中的balance加了10,所以再次打印的时候为10</li>
<li>上边两个方法的访问相当于子类中没有定义的方法和变量，会去长它的父类。</li>
</ul>


<h3>多继承</h3>

<p>除了单继承，lua还可以实现多重继承，继续看例子 <br/>
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
</pre></td><td class='code'><pre><code class='lua'><span class='line'><span class="kd">local</span> <span class="n">A</span> <span class="o">=</span> <span class="p">{}</span>
</span><span class='line'><span class="k">function</span> <span class="nf">A</span><span class="p">:</span><span class="n">hello</span><span class="p">(</span>  <span class="p">)</span>
</span><span class='line'>    <span class="nb">print</span><span class="p">(</span><span class="err">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="n">A</span> <span class="n">hello</span> <span class="n">method</span> <span class="err">&amp;</span><span class="n">rdquo</span><span class="p">;)</span>
</span><span class='line'><span class="k">end</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="kd">local</span> <span class="n">B</span> <span class="o">=</span> <span class="p">{}</span>
</span><span class='line'><span class="k">function</span> <span class="nf">B</span><span class="p">:</span><span class="n">world</span><span class="p">(</span>  <span class="p">)</span>
</span><span class='line'>    <span class="nb">print</span><span class="p">(</span><span class="err">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="n">B</span> <span class="n">world</span> <span class="n">method</span> <span class="err">&amp;</span><span class="n">rdquo</span><span class="p">;)</span>
</span><span class='line'><span class="k">end</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">function</span> <span class="nf">createClass</span><span class="p">(</span> <span class="err">&amp;</span><span class="n">hellip</span><span class="p">;</span> <span class="p">)</span>
</span><span class='line'>    <span class="kd">local</span> <span class="n">c</span> <span class="o">=</span> <span class="p">{}</span>
</span><span class='line'>    <span class="kd">local</span> <span class="n">parents</span> <span class="o">=</span> <span class="p">{</span> <span class="err">&amp;</span><span class="n">hellip</span><span class="p">;</span> <span class="p">}</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="kd">local</span> <span class="k">function</span> <span class="nf">search</span><span class="p">(</span> <span class="n">k</span><span class="p">,</span> <span class="n">parents</span> <span class="p">)</span>
</span><span class='line'>    <span class="k">for</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="o">#</span><span class="n">parents</span> <span class="k">do</span>
</span><span class='line'>        <span class="kd">local</span> <span class="n">func</span> <span class="o">=</span> <span class="n">parents</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span>
</span><span class='line'>        <span class="k">if</span> <span class="n">func</span> <span class="k">then</span>
</span><span class='line'>            <span class="k">return</span> <span class="n">func</span>
</span><span class='line'>        <span class="k">end</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="nb">setmetatable</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="p">{</span><span class="n">__index</span> <span class="o">=</span> <span class="k">function</span> <span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">search</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">parents</span><span class="p">)</span>
</span><span class='line'><span class="k">end</span><span class="p">})</span>
</span><span class='line'>
</span><span class='line'><span class="n">c</span><span class="p">.</span><span class="n">__index</span> <span class="o">=</span> <span class="n">c</span>
</span><span class='line'>
</span><span class='line'><span class="k">function</span> <span class="nf">c</span><span class="p">:</span><span class="n">new</span><span class="p">(</span> <span class="n">o</span> <span class="p">)</span>
</span><span class='line'>    <span class="n">o</span> <span class="o">=</span> <span class="n">o</span> <span class="ow">or</span> <span class="p">{}</span>
</span><span class='line'>    <span class="nb">setmetatable</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">o</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'><span class="k">return</span> <span class="n">c</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">end</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="n">C</span> <span class="o">=</span> <span class="n">createClass</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
</span><span class='line'><span class="n">c1</span> <span class="o">=</span> <span class="n">C</span><span class="p">:</span><span class="n">new</span><span class="p">()</span>
</span><span class='line'><span class="n">c1</span><span class="p">:</span><span class="n">hello</span><span class="p">()</span> <span class="err">&amp;</span><span class="n">ndash</span><span class="p">;</span> <span class="n">A</span> <span class="n">hello</span> <span class="n">method</span>
</span><span class='line'><span class="n">c1</span><span class="p">:</span><span class="n">world</span><span class="p">()</span> <span class="err">&amp;</span><span class="n">ndash</span><span class="p">;</span> <span class="n">B</span> <span class="n">world</span> <span class="n">method</span>
</span></code></pre></td></tr></table></div></figure></p>

<ul>
<li>先定义基类A,B，并分别定义了了方法</li>
<li>然后使用createClass()方法实现多重继承，其实可以看到，只是遍历两个基类表，找到对应的方法，并调用</li>
<li>C相当于继承自A，B，实现了多重继承，来看具体调用过程</li>
<li><code>c1 = C:new()</code>生成C的实例，C其实就是createClass()方法中的表c，(具体是c的一个副本)，所以<code>C:new()</code>调用的是<code>function c:new( o )</code>函数，返回一个以c表为元表的表</li>
<li>调用<code>c1:hello()</code>方法，因为<code>C:new()</code>返回的表中并未定义hello()方法，所以会去访问反回表的元表<code>__idnex</code>域，即<code>c.__index = c</code>，多以访问了c表，在c表中，也没有定义hello()方法，所以会继续访问c表的元表<code>__index</code>域，可以看到c表元表<code>__index</code>与定义的是一个函数，在这个函数中调用了search()函数，search()函数完成的一个功能是根据一个k查找由<code>createClass(A, B)</code>传进来参数生成的表parents，遍历parents中所有表，查找为k的值，此时k就是方法名，这个hello()方法会在A中找到，所以返回，所以最终调用了A中的hello()方法。</li>
<li>c1:world()同上，调用了B中的world()方法</li>
<li>这样就实现了多重继承，使得子类可以访问父类方法。但这只是简单的模拟实现了多重继承，具体多重继承中的好多问题并未解决。</li>
</ul>


<h3>封装</h3>

<p>类的一大作用就是封装，使得我们可以选择性的对外暴露的借口。
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
</pre></td><td class='code'><pre><code class='lua'><span class='line'><span class="k">function</span> <span class="nf">newAccount</span><span class="p">(</span> <span class="n">initValue</span> <span class="p">)</span>
</span><span class='line'>    <span class="kd">local</span> <span class="n">self</span> <span class="o">=</span> <span class="p">{</span> <span class="n">balance</span> <span class="o">=</span> <span class="n">initValue</span> <span class="p">}</span>
</span><span class='line'>    <span class="kd">local</span> <span class="n">hello</span> <span class="o">=</span> <span class="k">function</span> <span class="p">(</span>  <span class="p">)</span>
</span><span class='line'>        <span class="nb">print</span><span class="p">(</span><span class="err">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="n">hello</span> <span class="n">method</span><span class="err">&amp;</span><span class="n">rdquo</span><span class="p">;)</span>
</span><span class='line'>    <span class="k">end</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="kd">local</span> <span class="n">world</span> <span class="o">=</span> <span class="k">function</span> <span class="p">(</span>  <span class="p">)</span>
</span><span class='line'>    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="s">world method&quot;</span><span class="p">)</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="kd">local</span> <span class="n">getBalance</span> <span class="o">=</span> <span class="k">function</span> <span class="p">(</span>  <span class="p">)</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">balance</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="k">return</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">hello</span> <span class="o">=</span> <span class="n">hello</span><span class="p">,</span>
</span><span class='line'>    <span class="n">getBalanceValue</span> <span class="o">=</span> <span class="n">getBalance</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">end</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="n">n</span> <span class="o">=</span> <span class="n">newAccount</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
</span><span class='line'><span class="n">n</span><span class="p">.</span><span class="n">hello</span><span class="p">()</span>
</span><span class='line'><span class="nb">print</span><span class="p">(</span><span class="n">n</span><span class="p">.</span><span class="n">getBalanceValue</span><span class="p">())</span>
</span><span class='line'><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span>
</span><span class='line'><span class="err">可以看到在表的最后生成一个新表，只将需要的方法暴露给外边，像上边</span><span class="n">newAccount</span><span class="err">中的</span><span class="n">world</span><span class="p">()</span><span class="err">方法就只能在内部访问，外部无法访问。</span>
</span><span class='line'><span class="p">[</span><span class="err">《</span><span class="n">Programming</span> <span class="k">in</span> <span class="n">Lua</span><span class="err">》</span><span class="p">](</span><span class="n">http</span><span class="p">:</span><span class="o">//</span><span class="n">www</span><span class="p">.</span><span class="n">lua</span><span class="p">.</span><span class="n">org</span><span class="o">/</span><span class="n">pil</span><span class="o">/</span><span class="mf">16.5</span><span class="p">.</span><span class="n">html</span><span class="p">)</span><span class="err">中讲到一种使用闭包实现更高效的方法。</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="n">lua</span>
</span><span class='line'><span class="k">function</span> <span class="nf">newObject</span><span class="p">(</span> <span class="n">value</span> <span class="p">)</span>
</span><span class='line'>    <span class="k">return</span> <span class="k">function</span> <span class="p">(</span><span class="n">action</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
</span><span class='line'>        <span class="k">if</span> <span class="n">action</span> <span class="o">==</span> <span class="err">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="n">get</span><span class="err">&amp;</span><span class="n">rdquo</span><span class="p">;</span> <span class="k">then</span> <span class="k">return</span> <span class="n">value</span>
</span><span class='line'>        <span class="k">elseif</span> <span class="n">action</span> <span class="o">==</span> <span class="err">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="n">set</span><span class="err">&amp;</span><span class="n">rdquo</span><span class="p">;</span> <span class="k">then</span> <span class="n">value</span> <span class="o">=</span> <span class="n">v</span>
</span><span class='line'>        <span class="k">else</span> <span class="nb">error</span><span class="p">(</span><span class="err">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="n">invalid</span> <span class="n">action</span><span class="err">&amp;</span><span class="n">rdquo</span><span class="p">;)</span>
</span><span class='line'>        <span class="k">end</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'><span class="k">end</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="n">d</span> <span class="o">=</span> <span class="n">newObject</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</span><span class='line'><span class="nb">print</span><span class="p">(</span><span class="n">d</span><span class="p">(</span><span class="err">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="n">get</span><span class="err">&amp;</span><span class="n">rdquo</span><span class="p">;))</span>    <span class="err">&amp;</span><span class="n">ndash</span><span class="p">;</span><span class="o">&gt;</span> <span class="mi">0</span>
</span><span class='line'><span class="n">d</span><span class="p">(</span><span class="err">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="n">set</span><span class="err">&amp;</span><span class="n">rdquo</span><span class="p">;,</span> <span class="mi">10</span><span class="p">)</span>
</span><span class='line'><span class="nb">print</span><span class="p">(</span><span class="n">d</span><span class="p">(</span><span class="err">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="n">get</span><span class="err">&amp;</span><span class="n">rdquo</span><span class="p">;))</span>    <span class="err">&amp;</span><span class="n">ndash</span><span class="p">;</span><span class="o">&gt;</span> <span class="mi">10</span>
</span></code></pre></td></tr></table></div></figure></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Lua -- Metatables]]></title>
    <link href="http://ypengju.github.io/blog/2014/10/04/lua-metatables/"/>
    <updated>2014-10-04T17:10:37+08:00</updated>
    <id>http://ypengju.github.io/blog/2014/10/04/lua-metatables</id>
    <content type="html"><![CDATA[<p>通过lua中的元表及元方法，我们可以定义一些原本在lua中不存在的操作，比如两个表的相加，相减，大小比较，而且lua中的类的继承，类的封装这些面向对象操作也是借助于元表来完成的。</p>

<h3>设置获取元表</h3>

<p>lua中是通过setmetatable()和getmetatable()方法来分别设置和获取一个表的元表的。<!--more-->一个表默认是没有元表的，如下：<br/>
<code>lua
t = {}
print(getmetatable(t))
</code> <br/>
打印为nil，说明表t没有元表。但当我们设置元表后，就可以获得元表地址了。 <br/>
<code>lua
t = {}
setmetatable(t, {})
print(getmetatable(t)) -- table: 0x7fc4aa408580
</code></p>

<h3>元方法</h3>

<p>一个表拥有元表后，就可以添加元方法了。</p>

<h4>算术元方法</h4>

<pre><code class="lua">mt = {} --元表
--生成新表
function new(l)
    local set = {}
    setmetatable(set, mt)   -- 设置元表
    for k,v in pairs(l) do
        set[v] = true
    end
    return set
end
--打印表中元素
function tabletostring(l)
    local res = {}
    for k,v in pairs(l) do
        res[#res + 1] = k
    end
    return "{" .. table.concat(res, ", ") .. "}"
end
--定义 +操作
mt.__add = function ( a , b )
    local res = new{}
    for k in pairs(a) do
        res[k] = true
    end
    for k in pairs(b) do
        res[k] = true
    end
    return res
end
t1 = new{10, 20}
t2 = new{30, 40}
t = t1 + t2
print(tabletostring(t)) -- {20, 30, 40 10}
</code></pre>

<p>先申明一个元表mt，new方法用于生成新的表，所有用new方法生成的表都有相同的元表，然后在元表中实现<code>__add</code>方法，用于计算表的相加。这里用于将相加的两个表中元素统一到一个新表中。当t1 + t2时，会调用<code>__add</code>定义的方法，最后用tabletostring方法打印新表中的内容，这里可以看到，新表中统一了两个表的元素。 <br/>
当lua调用<code>+</code>操作时，首先查找左参数是否定义了<code>__add</code>域，如果定义了，调用这个<code>__add</code>操作，如果没定义，查找第二个参数，是否定义了<code>__add</code>域，如果定义了，调用第二个参数的<code>__add</code>域，如果两个参数都没有定义，就会报错。<br/>
与__add域一样，还可以定义其他域来完成表的<code>-</code>,<code>*</code>,<code>/</code>等操作</p>

<ul>
<li>__sub 减</li>
<li>__mul 乘</li>
<li>__div 除</li>
<li>__mod 取余</li>
<li>__unm 负值</li>
</ul>


<h4>逻辑元方法</h4>

<p>除了定义算数运算外，还可以定义逻辑运算，用来比较两个表的大小，但是lua中只制定了<code>__eq</code>,<code>__lt</code>,<code>__le</code>来分别代表，等于、小于、小于等于这三种操作，像其他的操作，比如不等，大于等操作，lua会基于上边三种进行转换，比如不等就是 not (a==b)。
<code>lua 小于等于
mt.__le = function ( a, b )
    for k,v in pairs(a) do
        if  not b[k] then return false end
    end
    return true
end
t1 = new{10, 20, 30}
t2 = new{10, 20}
print(t1 &lt;= t2) -- false
print(t2 &lt;= t1) -- true
</code> <br/>
遍历a表，如果a对应元素b表都有，说明a表小于等于b表，否则不小于等于。则根据上边，小于可定义如下
<code>lua 小于
mt.__le = function ( a, b )
    for k,v in pairs(a) do
        if  not b[k] then return false end
    end
    return true
end
mt.__lt = function ( a, b )
    return a &lt;= b and not (b &lt;= a)
end
t1 = new{10, 20, 30}
t2 = new{10, 20}
print(t1 &lt; t2)  --false
print(t2 &lt; t1)  --true
print(t1 &gt; t2)  --true
print(t1 &gt;= t2) --true
</code> <br/>
如果a&lt;b，则a&lt;=b必然成立，但b&lt;=a肯定不成立。同时可以看到可以用<code>&gt;</code>、<code>&gt;=</code>操作，这是因为lua帮我们自动转换了。
<code>lua 等于
mt.__eq = function ( a, b )
    return a &lt;= b and b &lt;= a
end
t1 = new{10, 20, 30}
t2 = new{10, 20}
print(t1 == t2) --false
print(t1 ~= t2) --true
</code>
同时我们可以根据小于等于快速定义等于操作，此时我们也可以使用<code>~=</code>不等于操作。</p>

<h4>库定义元方法</h4>

<pre><code class="lua">print({}) -- table: 0x7fad7bc03c80
</code></pre>

<p>默认情况下，使用print函数单元一个表的时候，打印的是他的地址。我们可以定义元表中的<code>__tostring</code>域来自定义打印的内容。 <br/>
<code>lua
function tabletostring(l)
    local res = {}
    for k,v in pairs(l) do
        res[#res + 1] = k
    end
    return "{" .. table.concat(res, ", ") .. "}"
end
mt.__tostring = tabletostring
t1 = new{10, 20, 30}
print(t1) --{10, 20, 30}   
</code> <br/>
将tabletostring方法赋值给<code>__tostring</code>域，当我们再次使用print函数打印new生成的表的时候，就讲真个表的内容打印出来了。  <br/>
<code>
t1 = new{10, 20, 30}
print(getmetatable(t1)) --table: 0x7f9851408c20
setmetatable(t1, {})    
print(getmetatable(t1)) --table: 0x7faef2409ea0
</code> <br/>
像上边这样，当再次给原来的表设置元表后，原来的设置的元表就失效了，为了防止这种情况发生，使得设置一次元表后不能更改，我们可以实现元表的<code>__metatable</code>域，来防止元表被更改。
<code>
mt.__metatable = "this is metatable"
t1 = new{10, 20, 30}
print(getmetatable(t1)) --this is metatable
setmetatable(t1, {})  -- 报错 cannot change a protected metatable
</code> <br/>
当调用getmetatable时，将放回我们定义的<code>__metatable</code>域的值，当再次设置元表时，就会报错，提示元表是被保护的。</p>

<h4>表访问元方法</h4>

<p>当访问表中不存在的元素时，lua会返回nil，其实我们可以利用元表，自定义返回的值。
<code>
mt.__index = function (_, k)
    return 300
end
t1 = new{10, 20, 30}
print(t1[5]) -- 300
</code><br/>
像上边这样，当访问下标为5的元素时，元表中是没有的，本来应该返回的是nil，但当我们定义了<code>__index</code>域时，返回值就是300了。 <br/>
<code>__index</code>的定义有两种，一种是像上边这样使用函数，一种是使用表 <br/>
<code>
t2 = {100, 200, 300, 400, 500, 600}
mt.__index = t2
t1 = new{10, 20, 30}
print(t1[5]) -- 500
</code> <br/>
像上边这样直接使用表定义<code>__index</code>域，当访问t1中下标为5的元素时，t1中并不存在，但我们定义元表中的<code>__index</code>域，此时就会访问t2中下标为5的元素，并返回，所以t1[5]返回的值就是500。<br/>
还可以定义<code>__newindex</code>域操作给表中不存在的元素赋值时的操作。
<code>lua
t1 = new{10, 20, 30}
mt.__newindex = function ()
    print("new index")
end
t1[5] = 1 -- new index
</code> <br/>
当对不存在的元素赋值时，就会调用<code>__newindex</code>域定义的方法。</p>

<p>像上边这样用new生成的所有新表都共享同一个元表，这就有点像c++中类生成无数实例一样，而访问不存在的元素，就会查找<code>__index</code>域，这就有点像在c++中，访问子类没有的方法，就去父类查找。而lua就是用这种特性来实现面向对象编程的。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Lua -- Table]]></title>
    <link href="http://ypengju.github.io/blog/2014/10/03/lua-table/"/>
    <updated>2014-10-03T20:43:27+08:00</updated>
    <id>http://ypengju.github.io/blog/2014/10/03/lua-table</id>
    <content type="html"><![CDATA[<p>lua并不像其他语言一样提供了Array，List，Set，Queue等各种数据结构来完成各种不同数据操作，相比，lua只提供了一种数据结构 &ndash; Table，可谓以不变应万变了。 <br/>
lua的table可以以整数和字符串为下标，但是我们可以在一个table中存储各种数据，可以存储数据，字符串，函数，甚至表等各种结构，</p>

<h3>整数索引</h3>

<p>lua以整数为下标时，我们就可以像数组一样直接使用，其实lua底层，table是由两部分组成的，一部分是数组，用来存储像整数下标的这些值，一部分用哈希表来实现，用来存储像字符串这样索引的值。lua对table的大小没有限制，也就是说我们可以在使用过程中，在table中添加元素。  <!--more-->
<code>
table1 = {10, 30, 50, 70, 90}
print(table1[0])   -- nil
print(table1[1])   -- 10
</code> <br/>
可以看到访问table1[0]返回nil，而table1[1]访问表中第一个值。当我们访问表中不存在的值时会返回nil值，默认table下标是从1开始的，而不是我们熟悉的像其他语言中从0开始，table可以使用任意整数为下标。
<code>
table2 = {10, 30, 50, 70, 90}
table3 = {[1] = 10, [2] = 30, [3] = 50, [4] = 70, [5] = 90}
</code><br/>
上边这两种形式是等价的。 <br/>
<code>
table2 = {10, 30, 50, 70, 90}
table3 = {[1] = 10, [2] = 30, [3] = 50, [40] = 70, [5] = 90}
table5 = {[2] = 30, [3] = 50}
print(#table2)  -- 5
print(#table3)  -- 3
print(#table4)  -- 2
print(#table5)  -- 0
</code> <br/>
可以使用#操作来计算下标从1开始并连续的table的大小，从上边例子可以看到，如果数组从零开始或者中间有下标不连续，计算的talbe的大小就只是从1到连续结束的元素的个数，如果table元素不是以1下标开始的计算结果为0。</p>

<h3>字符串索引</h3>

<pre><code>table1 = {one = 0, two = true, three = "hello"}
table2 = {["one"] = 0, ["two"] = true, ["three"] = "hello"}
table3 = {}
table3.one = 0
table3.two = true
table3.three = "hello"
</code></pre>

<p>上边这三种形式创建的表都是一样的。但是有字符串索引的时候，就不能直接采用#操作求table的大小了。如果需要知道table的大小，肯能就需要一个计数器了。</p>

<h3>遍历</h3>

<pre><code>table1 = {10, 30, 50, 70, 90}
for i=1, #table1 do
    print(table1[i])
end
</code></pre>

<p>像上边这样，当table使用整数索引的时候，我们可以像在其他语言中使用数组一样访问表中的元素。但是当下标不为整数，或者整数下标不连续时，我们就无法求得table的大小，上边这种遍历table的方法就行不通了，为了能够方便的遍历table，lua为我们提供了两个有用的方法pairs和ipairs。 <br/>
<code>
table2 = {10, 30, [4] = 50, [10] = 70, [14] = 90, hello = "world"}
for k,v in pairs(table2) do
    print(k,v)
end  
</code> <br/>
使用pairs以key-valued的形式遍历了table2中所有的元素，就像我们在c++中使用迭代器一样。<br/>
<code>
table2 = {10, 30, [4] = 50, [10] = 70, [14] = 90, hello = "world"}
for i,v in ipairs(table2) do
    print(i,v)
end
</code> <br/>
但是当使用ipairs遍历时，只是访问了前两个元素，这是因为ipairs只遍历下标从1开始，连续增长的表。像上边table1这样的表，ipairs可以完全遍历，所以在使用的时候需要注意，当下标不连续，或者索引不是整数时，ipairs就停止遍历接下来的元素。</p>

<h3>库方法</h3>

<p>为了方便操作表，lua提供了几个对表操作的库方法</p>

<h4>table.concat(list [, sep [, i [, j]]]) - 链接表中的元素，返回字符串。</h4>

<pre><code>tab = {"hello", "world", "lua"}
print(table.concat(tab, ":"))  -- hello:world:lua
</code></pre>

<p>有四个参数，后三个可选，第一个参数是表， 第二个参数分隔符，像上边的冒号，默认为空字符， 第三个参数，开始字符位置，默认下标为1， 第四个参数，结束下标，默认为表的大小。所以默认是链接整个表，我们也可以指定链接表中指定下标区域内的元素。</p>

<h4>table.insert(list, [pos,] value) - 插入元素</h4>

<pre><code>tab = {"hello", "world", "lua"}
table.insert(tab, 100)
print(table.concat(tab, ": ")) -- hello: world: lua: 100
</code></pre>

<p>有三个参数，第一个表，第二个参数可选，插入的位置，默认是#table+1，第三个参数要插入的值，所以默认是讲元素插入到表最后的。像上边这样只有两个参数的，其实是省略掉了中间第二个元素，插值在最后。</p>

<h4>table.pack(···) - 将所有参数打包到一个表中</h4>

<pre><code>tab = table.pack("hello", "world", "lua", 1, 4)
for k,v in pairs(tab) do
    print(k,v)
end
print(table.concat(tab, ": "))
</code></pre>

<p>接收任意多个参数，将所有参数打包到一个下标从1开始的表中，像上边，打包完后<code>tab1 = {"hello", "world", "lua", 1, 4}</code>但是不一定所有参数都是顺序打包的。</p>

<h4>table.unpack (list [, i [, j]]) - 跟table.pack相反</h4>

<pre><code>tab = {"hello", "world", "lua", 1, 4}
a, b, c, d, e = table.unpack(tab)
print(a) -- hello
print(b) -- world
print(c) -- lua
print(d) -- 1
print(e) -- 4
</code></pre>

<p>返回多个参数，也可以指定需要的坐标范围，比如只返回第二到第四个元素，那么就返回3个元素。</p>

<h4>table.remove(list [, pos]) - 移除表中元素</h4>

<pre><code>tab = {"hello", "world", "lua", 1, 4}
table.remove(tab, 2)
print(table.concat(tab, ": ")) -- hello: lua: 1: 4
print(tab[2]) -- lua
</code></pre>

<p>移除表中指定位置元素，有两个参数，第一个表，第二个移除元素的下标，可选，默认值是表中最后一个元素位置。第二个参数要在表的大小范围内，移除后指定位置元素后，下标后边元素向前移动。</p>

<h4>table.sort (list [, comp]) - 排序</h4>

<pre><code>tab = {4, 10, 2, 1, 40, 6}
table.sort(tab)
print(table.concat(tab, " "))
</code></pre>

<p>对表中元素进行排序，默认从小到大，在第二个参数中也可以实现自己的排序条件 <br/>
<code>
tab = {4, 10, 2, 1, 40, 6}
table.sort(tab, function(a, b)
    return a &gt; b
end)
print(table.concat(tab, " "))
</code> <br/>
talbe除了像数组这种操作外，还可以用来实现其他数据结构，但是在lua中像List，Set这种数据结构，不一定比table方便，除了数据结构的操作外，lua还可以用表实现类的封装，继承等面向对象特性，而这一切都是基于元表的，感觉Lua的table无所不能啊。</p>

<p>List，Set实现看见<a href="http://www.lua.org/pil/11.3.html">《Programming in lua》</a></p>
]]></content>
  </entry>
  
</feed>
